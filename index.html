<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Bugura Quiz (Web – Turnos basados en “usuarios”)</title>
  <style>
    /* ————————————————————————————————————————————————————
       Estilos para modo oscuro y responsive
       ———————————————————————————————————————————————————— */
    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      background-color: #121212;
      color: #FFFFFF;
    }
    .container {
      max-width: 480px;
      margin: 0 auto;
      padding: 16px;
    }
    h1, h2, h3, h4 {
      color: #FFFFFF;
      margin-bottom: 12px;
    }
    .title {
      color: #FF0000;
      text-align: center;
      font-size: 2em;
      margin-bottom: 24px;
      text-shadow:
        2px 2px 0px #000000,
        4px 4px 0px #000000,
        6px 6px 0px #000000;
    }
    input[type="text"] {
      width: 100%;
      padding: 10px;
      margin-bottom: 12px;
      background-color: #1E1E1E;
      border: 1px solid #333333;
      border-radius: 4px;
      color: #FFFFFF;
      box-sizing: border-box;
    }
    button {
      background-color: #BB86FC;
      border: none;
      color: #000000;
      padding: 10px 16px;
      margin: 4px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
    }
    button:disabled {
      background-color: #555555;
      color: #AAAAAA;
      cursor: default;
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 12px;
    }
    .message {
      margin-top: 8px;
      color: #CF6679;
    }
    .list-item {
      margin-left: 16px;
      margin-bottom: 4px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .hidden {
      display: none;
    }
    .center {
      text-align: center;
      margin-top: 24px;
    }
    .question-text {
      font-size: 18px;
      margin: 16px 0;
    }
    .score-list {
      margin-top: 16px;
    }
    .score-item {
      margin-bottom: 4px;
    }
    @media (max-width: 480px) {
      .container {
        padding: 8px;
      }
      button {
        flex: 1 1 48%;
      }
      .title {
        font-size: 1.5em;
        text-shadow:
          1px 1px 0px #000000,
          2px 2px 0px #000000,
          3px 3px 0px #000000;
      }
    }
    .crown-icon {
      width: 20px;
      height: 20px;
      fill: gold;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- ——— Pantalla “Join Room” ——— -->
    <div id="join-screen">
      <h1 class="title">Bugura Quiz</h1>
      <input type="text" id="input-room-id" placeholder="ID de la sala" />
      <input type="text" id="input-username" placeholder="Nombre de usuario" />

      <div class="row">
        <button id="btn-create-room">Crear Sala</button>
        <button id="btn-join-room">Unirse a Sala</button>
        <button id="btn-reset-all">Reiniciar Salas</button>
      </div>

      <div id="message" class="message"></div>

      <h3>Usuarios en sala:</h3>
      <ul id="users-list"></ul>

      <div id="countdown" class="center"></div>

      <h3>Ranking General</h3>
      <ul id="ranking-list"></ul>
    </div>

    <!-- ——— Pantalla “Quiz” ——— -->
    <div id="quiz-screen" class="hidden">
      <h2 class="center">Quiz en Curso</h2>
      <div id="quiz-question" class="question-text"></div>
      <div id="turn-indicator" class="center"></div>
      <div id="quiz-options" class="row"></div>
      <div id="quiz-scores" class="score-list"></div>
      <div id="winner" class="center"></div>
    </div>
  </div>

  <!-- Firebase SDK v9 + lógica JS -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
    import {
      getDatabase,
      ref,
      set,
      onValue,
      runTransaction,
      remove
    } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-database.js";

    // 1) Configuración de Firebase: mismo proyecto que Android
    const firebaseConfig = {
      apiKey: "AIzaSyDAYh1x8p1wbdNEM4nA33y9sWh2Q3MrLxo",
      authDomain: "bugura-cf2cd.firebaseapp.com",
      databaseURL: "https://bugura-cf2cd-default-rtdb.firebaseio.com",
      projectId: "bugura-cf2cd",
      storageBucket: "bugura-cf2cd.firebasestorage.app",
      messagingSenderId: "170908399149",
      appId: "1:170908399149:web:5e9ab4cf06e8079fe16aa4"
    };
    const app = initializeApp(firebaseConfig);
    const db  = getDatabase(app);

    // 2) Variables globales
    let currentRoomId       = "";
    let currentUserName     = "";
    let countdownTimer      = null;
    let hasCountdownStarted = false;
    let countdownValue      = 15;

    // Referencias DOM
    const joinScreenDiv    = document.getElementById("join-screen");
    const quizScreenDiv    = document.getElementById("quiz-screen");
    const roomIdInput      = document.getElementById("input-room-id");
    const userNameInput    = document.getElementById("input-username");
    const btnCreateRoom    = document.getElementById("btn-create-room");
    const btnJoinRoom      = document.getElementById("btn-join-room");
    const btnResetAll      = document.getElementById("btn-reset-all");
    const messageDiv       = document.getElementById("message");
    const usersListUl      = document.getElementById("users-list");
    const countdownDiv     = document.getElementById("countdown");
    const quizQuestionText = document.getElementById("quiz-question");
    const turnIndicatorDiv = document.getElementById("turn-indicator");
    const quizOptionsDiv   = document.getElementById("quiz-options");
    const quizScoresDiv    = document.getElementById("quiz-scores");
    const winnerDiv        = document.getElementById("winner");
    const rankingListUl    = document.getElementById("ranking-list");

    // Banco de preguntas (idéntico a Android)
    const questions = [
      { text: "¿Capital de Francia?", options: ["Londres","Madrid","París","Berlín"], correctIndex: 2 },
      { text: "¿5 + 7 = ?",         options: ["10","12","11","14"],       correctIndex: 1 },
      { text: "¿Color del cielo?",  options: ["Verde","Azul","Rojo","Amarillo"], correctIndex: 1 }
    ];

    // 3) Funciones auxiliares
    function showMessage(txt) {
      messageDiv.textContent = txt;
      setTimeout(() => { messageDiv.textContent = ""; }, 3000);
    }
    function clearUsersList() {
      usersListUl.innerHTML = "";
    }
    function clearRankingList() {
      rankingListUl.innerHTML = "";
    }

    // 4) CREATE ROOM (igual que en Android)
    function createRoom() {
      const roomId   = roomIdInput.value.trim();
      const userName = userNameInput.value.trim();
      if (!roomId || !userName) {
        showMessage("Completa ambos campos");
        return;
      }
      currentRoomId   = roomId;
      currentUserName = userName;

      // 4.1) Inicializar “salas/{roomId}/state” exactamente
      set(ref(db, `salas/${roomId}/state`), {
        turnIndex: 0,
        questionIndex: 0,
        scores: { [userName]: 0 }
      })
      .then(() => {
        // 4.2) Añadir “salas/{roomId}/usuarios/{userName} = true”
        return set(ref(db, `salas/${roomId}/usuarios/${userName}`), true);
      })
      .then(() => {
        // 4.3) Empezar a escuchar usuarios en la sala
        listenToUsers(roomId);
        showMessage(`Sala creada: ${roomId}`);
      })
      .catch(err => {
        showMessage("Error al crear sala: " + err.message);
      });
    }

    // 5) JOIN ROOM (igual que Android)
    function joinRoom() {
      const roomId   = roomIdInput.value.trim();
      const userName = userNameInput.value.trim();
      if (!roomId || !userName) {
        showMessage("Completa ambos campos");
        return;
      }
      currentRoomId   = roomId;
      currentUserName = userName;

      // 5.1) Añadir “salas/{roomId}/usuarios/{userName} = true”
      set(ref(db, `salas/${roomId}/usuarios/${userName}`), true)
      .then(() => {
        // 5.2) Asegurar “salas/{roomId}/state/scores/{userName} = 0”
        return set(ref(db, `salas/${roomId}/state/scores/${userName}`), 0);
      })
      .then(() => {
        // 5.3) Empezar a escuchar usuarios en la sala
        listenToUsers(roomId);
        showMessage(`Unido a la sala: ${roomId}`);
      })
      .catch(err => {
        showMessage("Error al unirse: " + err.message);
      });
    }

    // 6) RESET ALL
    function resetAll() {
      remove(ref(db, "salas"))
      .then(() => {
        showMessage("Todas las salas fueron reiniciadas");
        clearUsersList();
        clearRankingList();
        countdownDiv.textContent = "";
        hasCountdownStarted = false;
        if (countdownTimer) {
          clearInterval(countdownTimer);
          countdownTimer = null;
        }
      })
      .catch(err => {
        showMessage("Error al reiniciar: " + err.message);
      });
    }

    // 7) LISTENER a “salas/{roomId}/usuarios”
    function listenToUsers(roomId) {
      hasCountdownStarted = false;
      countdownValue = 15;
      countdownDiv.textContent = "";

      const usuariosRef = ref(db, `salas/${roomId}/usuarios`);
      onValue(usuariosRef, snapshot => {
        const users = snapshot.val() || {};
        const userList = Object.keys(users);

        // Actualizar lista de usuarios
        usersListUl.innerHTML = "";
        userList.forEach(user => {
          const li = document.createElement("li");
          li.textContent = user;
          usersListUl.appendChild(li);
        });

        // Si hay ≥ 3 jugadores y aún no arrancó cuenta atrás, iniciarla
        if (userList.length >= 3 && !hasCountdownStarted) {
          startCountdown();
        }
      });
    }

    // 8) LISTENERS a “salas/{roomId}/state/turnIndex”, “salas/{roomId}/state/questionIndex” y “salas/{roomId}/state/scores”
    function listenToState(roomId) {
      // A) Listener para turnIndex
      const turnRef = ref(db, `salas/${roomId}/state/turnIndex`);
      onValue(turnRef, snapshot => {
        const turnIndex = snapshot.val();
        if (turnIndex === null || turnIndex === undefined) return;

        // Cuando cambia el turno, recalculamos lista de usuarios desde /usuarios y pregunta actual
        getUsuariosAndQuestionOnce(roomId).then(({ usuarios, questionIndex }) => {
          const userList = Object.keys(usuarios).sort();
          if (userList.length === 0) return;
          const currentPlayer = userList[turnIndex % userList.length];

          // Actualizar indicador de turno
          turnIndicatorDiv.textContent = `Turno de: ${currentPlayer}`;

          // Regenerar botones para la pregunta actual, con estado correcto
          showQuestionUI(questionIndex, currentPlayer);
        });
      });

      // B) Listener para questionIndex
      const qRef = ref(db, `salas/${roomId}/state/questionIndex`);
      onValue(qRef, snapshot => {
        const questionIndex = snapshot.val();
        if (questionIndex === null || questionIndex === undefined) return;
        if (questionIndex >= questions.length) {
          endQuizUI();
          return;
        }
        // Cuando cambia la pregunta, leemos lista de usuarios y turno para dibujar UI
        getUsuariosAndTurnOnce(roomId).then(({ usuarios, turnIndex }) => {
          const userList = Object.keys(usuarios).sort();
          if (userList.length === 0) return;
          const currentPlayer = userList[turnIndex % userList.length];
          // Actualizar indicador de turno
          turnIndicatorDiv.textContent = `Turno de: ${currentPlayer}`;
          // Generar botones para nueva pregunta
          showQuestionUI(questionIndex, currentPlayer);
        });
      });

      // C) Listener para scores: actualiza ranking
      const scoresRef = ref(db, `salas/${roomId}/state/scores`);
      onValue(scoresRef, snapshot => {
        const scores = snapshot.val() || {};
        updateRankingUI(scores);
      });
    }

    // 9) Leer simultáneamente “usuarios” y “questionIndex”
    function getUsuariosAndQuestionOnce(roomId) {
      return new Promise(resolve => {
        let result = {};
        const usuariosRef = ref(db, `salas/${roomId}/usuarios`);
        onValue(usuariosRef, snapU => {
          result.usuarios = snapU.val() || {};
          const qRef = ref(db, `salas/${roomId}/state/questionIndex`);
          onValue(qRef, snapQ => {
            result.questionIndex = snapQ.val() || 0;
            resolve(result);
          }, { onlyOnce: true });
        }, { onlyOnce: true });
      });
    }

    // 10) Leer simultáneamente “usuarios” y “turnIndex”
    function getUsuariosAndTurnOnce(roomId) {
      return new Promise(resolve => {
        let result = {};
        const usuariosRef = ref(db, `salas/${roomId}/usuarios`);
        onValue(usuariosRef, snapU => {
          result.usuarios = snapU.val() || {};
          const turnRef = ref(db, `salas/${roomId}/state/turnIndex`);
          onValue(turnRef, snapT => {
            result.turnIndex = snapT.val() || 0;
            resolve(result);
          }, { onlyOnce: true });
        }, { onlyOnce: true });
      });
    }

    // 11) Leer solo “usuarios” una sola vez
    function getUsuariosOnce(roomId) {
      return new Promise(resolve => {
        const usuariosRef = ref(db, `salas/${roomId}/usuarios`);
        onValue(usuariosRef, snap => {
          resolve(snap.val() || {});
        }, { onlyOnce: true });
      });
    }

    // 12) CUENTA ATRÁS (15 s) y luego transición a Quiz
    function startCountdown() {
      hasCountdownStarted = true;
      countdownDiv.textContent = `Comienza en ${countdownValue} s`;
      countdownTimer = setInterval(() => {
        countdownValue--;
        if (countdownValue > 0) {
          countdownDiv.textContent = `Comienza en ${countdownValue} s`;
        } else {
          clearInterval(countdownTimer);
          countdownDiv.textContent = "¡Arranca el juego!";
          setTimeout(() => {
            transitionToQuiz();
          }, 500);
        }
      }, 1000);
    }

    // 13) TRANSICIÓN a Quiz
    function transitionToQuiz() {
      joinScreenDiv.classList.add("hidden");
      quizScreenDiv.classList.remove("hidden");
      // Arrancamos los listeners de Turnos/Preguntas basados en “usuarios”
      listenToState(currentRoomId);
    }

    // 14) Mostrar pregunta y opciones basadas en questionIndex & currentPlayer
    function showQuestionUI(questionIndex, currentPlayer) {
      if (questionIndex >= questions.length) return;
      const qObj = questions[questionIndex];
      quizQuestionText.textContent = qObj.text;
      quizOptionsDiv.innerHTML = "";

      qObj.options.forEach((opt, idx) => {
        const btn = document.createElement("button");
        btn.textContent = opt;
        btn.disabled = (currentPlayer !== currentUserName);
        btn.addEventListener("click", () => handleAnswer(idx));
        quizOptionsDiv.appendChild(btn);
      });
    }

    // 15) Actualizar marcador en UI (ランキング)
    function updateRankingUI(scores) {
      const sorted = Object.entries(scores).sort((a,b) => b[1] - a[1]);
      rankingListUl.innerHTML = "";
      sorted.forEach(([user, score], idx) => {
        const li = document.createElement("li");
        li.classList.add("list-item");
        li.textContent = `${idx + 1}. ${user} — ${score} pts`;
        if (idx === 0) {
          const crownSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
          crownSvg.setAttribute("viewBox", "0 0 24 24");
          crownSvg.setAttribute("class", "crown-icon");
          const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
          path.setAttribute("d", "M5 16L3 6l5 4 4-5 4 5 5-4-2 10H5z");
          path.setAttribute("fill", "gold");
          crownSvg.appendChild(path);
          li.insertBefore(crownSvg, li.firstChild);
        }
        rankingListUl.appendChild(li);
      });
    }

    // 16) Manejar respuesta cuando es mi turno (runTransaction usando “usuarios”)
    function handleAnswer(selectedIndex) {
      const stateRef = ref(db, `salas/${currentRoomId}/state`);
      runTransaction(stateRef, state => {
        if (!state) return state;
        const qIndex = state.questionIndex || 0;
        const scores = state.scores || {};
        const turnIndex = state.turnIndex || 0;

        // Leemos lista de usuarios (orden alfabético)
        // Esto garantiza mismo orden en Chrome y Android
        // Se usa { onlyOnce: true } dentro de la transacción
        // ¡OJO! Firebase SDK v9: no se puede mezclar onValue({onlyOnce: true}) *dentro* de runTransaction
        // Por eso hemos refactorizado un poco: antes de llamar a runTransaction,
        // debemos ya tener “usuarios” cargado en caché. Simplificamos asumiendo que no cambia
        // durante el quiz. (Si se saliera alguien en medio, no se contempla aquí.)

        // Construimos userList a partir de state._cachedUsuarios:
        const userList = state._cachedUsuarios || [];
        // Si no tenemos cached, abortamos para evitar inconsistencias
        if (!Array.isArray(userList) || userList.length === 0) return state;

        const currentPlayer = userList[turnIndex % userList.length];
        if (currentPlayer !== currentUserName) return state;

        const qObj = questions[qIndex];
        if (!qObj) return state;

        if (selectedIndex === qObj.correctIndex) {
          state.scores[currentUserName] = (state.scores[currentUserName] || 0) + 1;
        }

        const nextTurn = (turnIndex + 1) % userList.length;
        if (nextTurn === 0) {
          state.questionIndex = qIndex + 1;
        }
        state.turnIndex = nextTurn;
        return state;
      }, {
        // Callback onComplete para debug
        onComplete: (err, committed, snapshot) => {
          if (err) console.error("runTransaction error:", err);
          if (!committed) console.warn("Transaction no comprometida");
        }
      });
    }

    // 17) Finalizar quiz en UI
    function endQuizUI() {
      const scoresRef = ref(db, `salas/${currentRoomId}/state/scores`);
      onValue(scoresRef, snap => {
        const finalScores = snap.val() || {};
        const sorted = Object.entries(finalScores).sort((a,b) => b[1] - a[1]);
        if (sorted.length) {
          const [winnerName, winnerScore] = sorted[0];
          winnerDiv.innerHTML = `<h3>¡Ganador: ${winnerName} con ${winnerScore} pts!</h3>`;
        } else {
          winnerDiv.textContent = "No hay participantes.";
        }
      }, { onlyOnce: true });

      setTimeout(() => {
        resetToJoin();
      }, 5000);
    }

    // 18) Resetear a Join Room
    function resetToJoin() {
      quizQuestionText.textContent = "";
      turnIndicatorDiv.textContent = "";
      quizOptionsDiv.innerHTML = "";
      quizScoresDiv.innerHTML = "";
      winnerDiv.textContent = "";

      joinScreenDiv.classList.remove("hidden");
      quizScreenDiv.classList.add("hidden");
      clearUsersList();
      clearRankingList();
      countdownDiv.textContent = "";
      hasCountdownStarted = false;
      if (countdownTimer) {
        clearInterval(countdownTimer);
        countdownTimer = null;
      }
    }

    // 19) Antes de arrancar runTransaction necesitamos tener “usuarios” en caché dentro de state.
    //     Por simplicidad, justo antes de empezar el Quiz, leemos /usuarios y metemos bajo state._cachedUsuarios.
    //     De esta forma runTransaction puede usarlo sin bloqueos.
    function cacheUsuariosEnState(roomId) {
      return new Promise(resolve => {
        const usuariosRef = ref(db, `salas/${roomId}/usuarios`);
        onValue(usuariosRef, snap => {
          const usuariosObj = snap.val() || {};
          const userList = Object.keys(usuariosObj).sort();
          // Guardamos esa lista en un nodo “fantasma” dentro de state
          // No se escribe a Firebase; lo mantenemos localmente:
          resolve(userList);
        }, { onlyOnce: true });
      });
    }

    // 20) Al iniciar Quiz, primero leemos y cacheamos “usuarios”
    function transitionToQuiz() {
      joinScreenDiv.classList.add("hidden");
      quizScreenDiv.classList.remove("hidden");
      cacheUsuariosEnState(currentRoomId).then(userList => {
        // Creamos un “listener ligero” a state que, en cada snapshot, inyecte userList en state._cachedUsuarios
        const stateRef = ref(db, `salas/${currentRoomId}/state`);
        onValue(stateRef, snapshot => {
          const state = snapshot.val();
          if (!state) return;
          // metemos _cachedUsuarios sin escribir de vuelta:
          state._cachedUsuarios = userList;
        });
        // Ahora arrancamos los listeners de turno/pregunta:
        listenToState(currentRoomId);
      });
    }

    // 21) Reemplazamos la función original de transición
    //     (Ya definida más arriba, la sobreescribimos).
    //     Nota: Asegúrate de borrar la definición anterior de transitionToQuiz si existe.
    //     Aquí incluimos la nueva directamente, por eso no repetimos su firma.

    // 22) Eventos de botón
    btnCreateRoom.addEventListener("click", createRoom);
    btnJoinRoom.addEventListener("click", joinRoom);
    btnResetAll.addEventListener("click", resetAll);

    // Nota: Hemos redefinido transitionToQuiz en el paso 20, así que
    // antes de eso, si aparecía una definición anterior, bórrala.
  </script>
</body>
</html>
